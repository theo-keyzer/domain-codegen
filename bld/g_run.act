----------------------------------------------------------------
Actor main .
----------------------------------------------------------------

C package main
C 
C import (
C 	"strings"
C 	"fmt"
C 	"strconv"
C )
C
C type ActT struct {
C 	index       map[string]int

All Comp ar

C }
C


C func refs(act *ActT) int {
C 	errs := 0
C 	v := ""
C 	p := -1
C 	res := 0
C 	err := false

All Comp refs
All Comp refs2

C 	return(errs)
C }
C

-C List var_all(glob, va, lno) 
-C {
-C 	if (va.length < 3) {
-C 		return( [false, "?" + va.length.toString() + "<3?" + lno + "?"] );
-C 	}

-All Comp var_all

-C 	return( [false, "?" + va[0] + "?" + lno + "?"] );
-C }
-C


C func DoAll(glob *GlobT, va []string, lno string) int {

All Comp do_all

-C // ${._lno}
C 	fmt.Printf("?No all %s cmd ?%s? > ${._lno}", va[0], lno);
-C 	fmt.Printf("?No all %s cmd ?%s? ", va[0], lno);
C 	return 0;
C }
C

C func Load(act *ActT, toks string, ln string, pos int, lno string) int {
C 	errs := 0
C 	ss := strings.Split(toks,".")
C 	tok := ss[0]
C 	flag := ss[1:]

All Comp load

C 	return errs
C }
C

-C bool load(act, toks, ln, pos, lno)
-C {
-C 	bool errs = false;
-C 	var ss = toks.split(".");
-C 	var tok = ss[0];
-C 	var flag = ss.sublist(1);

-All Comp load

-C 	return(errs);
-C }

----------------------------------------------------------------
Actor ar .
----------------------------------------------------------------

-C 	List<Kp${name:c}> Ap${name:c} = [];
C 	Ap${name:c} [] *Kp${name:c}

----------------------------------------------------------------
Actor load .
----------------------------------------------------------------

C 	if tok == "${name:c}" { errs += load${name:c}(act,ln,pos,lno,flag) }

----------------------------------------------------------------
Actor refs Comp parent = Actor
----------------------------------------------------------------

Out delay

-C 	for(var st in act.Ap${name:c}) {
C 	for _, st := range act.Ap${name:c} {
		
Its Element refs_act_ele

C 	}

Break

----------------------------------------------------------------
Actor refs Comp name = Actor
----------------------------------------------------------------

Out delay

-C 	for(var st in act.Ap${name:c}) {
C 	for _, st := range act.Ap${name:c} {
		
Its Element refs_act_ele

C 	}

Break

----------------------------------------------------------------
Actor refs .
----------------------------------------------------------------

Out delay

C 	for _, st := range act.Ap${name:c} {
C
		
Its Element refs_ele

C 	}

----------------------------------------------------------------
Actor refs2 .
----------------------------------------------------------------

Out delay

C 	for _, st := range act.Ap${name:c} {
C
		
Its Element refs_ele2

C 	}

----------------------------------------------------------------
Actor refs_act_ele . type = ref
----------------------------------------------------------------

-C //  ${._lno}
C
C 		err, res = fnd2(act, "${comp.name:c}_" + st.K${name:l}, st.K${name:l},  ".", st.LineNo, "${._lno}" );
C 		st.K${name:l}p = res
C 		if (err == false) {
C 			errs += 1
C 		}

----------------------------------------------------------------
Actor refs_ele . type = ref
----------------------------------------------------------------

C //  ${._lno}
C
C 		v, _ = st.Names["${name:l}"]

C 		err, res = fnd3(act, "${comp.name:c}_" + v, v, "ref:${.refs.name:c}.${name:l}:${comp:c}." + v,  "${check}", st.LineNo, "${._lno}" );
C 		st.K${name:l}p = res
C 		if (err == false) {
C 			errs += 1
C 		}

----------------------------------------------------------------
Actor refs_ele . type = link
-Actor refs_ele . mw in F1,FS
----------------------------------------------------------------

C //  ${._lno}
C
C 		v, _ = st.Names["${name:l}"]
C 		err, res = fnd3(act, strconv.Itoa(st.Kparentp) + "_${comp.name:c}_" + v,v, "ref_link:${.refs.name:c}.${name:l}:${.refs.parent:c}." + st.Parent + ".${comp:c}." + v,  "${check}", st.LineNo, "${._lno}" );
C 		st.K${name:l}p = res
C 		if (err == false) {
C 			errs += 1
C 		}


----------------------------------------------------------------
Actor refs_ele2 . type = ref_child
-Actor refs_ele2 . mw in L1,LS
----------------------------------------------------------------

C //  ${._lno}
C
C  
C 	if st.K${previous.name:l}p < 0 && "${check}" != "*" {
C 		fmt.Printf("ref_child:${.refs2.name:c}.${name:l} unresolved from ${previous.type}:${.refs2.name:c}.${previous.name:l}:${previous.comp:c} %s > ${._lno}", st.LineNo)
C 		errs += 1
C 	} else {
-C 		parent := act.Ap${previous.comp:c}[st.Kparentp].MyName
C 		parent := act.Ap${previous.comp:c}[st.K${previous.name:l}p].MyName
C 		v, _ = st.Names["${name:l}"]
C 		err, res = fnd3(act, strconv.Itoa(st.K${previous.name:l}p) + "_${comp:c}_" + v, v, "ref_child:${.refs2.name:c}.${name:l}:${previous.comp:c}." + parent + "." + v + " from ${previous.type}:${.refs2.name:c}.${previous.name:l}", "${check}", st.LineNo, "${._lno}")
C 		st.K${name:l}p = res
C 		if !err {
C 			errs += 1
C 		}
C 	}


----------------------------------------------------------------
Actor refs_ele2 . type = ref_copy
----------------------------------------------------------------

C //  ${._lno}
C
C 	t := st.K${previous.name:l}p
C 	if t >= 0 {
C 		st.K${name:l}p = act.Ap${previous.comp.name:c}[t].K${name:l}p
C 	} else if "${check}" != "*" {
C 		fmt.Printf("ref_copy:${.refs2.name:c}.${name:l} unresolved from ${previous.type}:${.refs2.name:c}.${previous.name:l}:${previous.comp:c}.x %s (${check}) > ${._lno}\n", st.LineNo)
C 		errs += 1
C 	}

----------------------------------------------------------------
Actor refs_ele2 . type = up_copy
----------------------------------------------------------------

C //  ${._lno}

C 	p = st.Kparentp

Its parent.parent up

C 	if p >= 0 {
C 		st.K${name:l}p = p
C 	} else if "${check}" != "*" {
C 		fmt.Printf("ref_copy:${.refs2.name:c}.${name:l} unresolved from ${previous.type}:${.refs2.name:c}.${previous.name:l}:${previous.comp:c}.x %s (${check}) > ${._lno}\n", st.LineNo)
C 		errs += 1
C 	}

----------------------------------------------------------------
Actor up . name = ${.refs_ele2.comp:c}
----------------------------------------------------------------
Break
----------------------------------------------------------------
Actor up .
----------------------------------------------------------------

C 	p = act.Ap${name:c}[p].Kparentp

Its parent up

----------------------------------------------------------------
Actor var_all Comp find = Find
----------------------------------------------------------------

C 	if (va[0].compareTo("${name:c}") == 0) {
C 		var en = glob.dats.index["${name:c}_" + va[1] ];
C 		if(en != null) {
C 			return (glob.dats.Ap${name:c}[en].get_var(glob, va.sublist(2), lno));
C 		}
C 		return( [false, "?" + va[0] + "=" + va[1] + "?" + lno + "?"] );
C 	}
	
----------------------------------------------------------------
Actor do_all Comp parent != Actor
----------------------------------------------------------------

C 	if va[0] == "${name:c}" {
C 		if (len(va) > 1 && len(va[1]) > 0) {
C 			en, er := glob.Dats.index["${name:c}_" + va[1] ];
C 			if !er {
C 				if len(va) > 2 {
C 					return( glob.Dats.Ap${name:c}[en].DoIts(glob, va[2:], lno) )
C 				}
C 				return( GoAct(glob, glob.Dats.Ap${name:c}[en]) )
C 			}
C 			return(0)
C 		}
C 		for _, st := range glob.Dats.Ap${name:c} {
C 			if len(va) > 2 {
C 				ret := st.DoIts(glob, va[2:], lno)
C 				if ret != 0 {
C 					return(ret)
C 				}
C 				continue
C 			}
C 			ret := GoAct(glob, st)
C 			if ret != 0 {
C 				return(ret)
C 			}
C 		}
C 		return(0)
C 	}


----------------------------------------------------------------
Actor do_all_ele Element name = name
----------------------------------------------------------------

C 			if b != "" { if st.kname != b { continue; } }


